{
  "$schema": "../schemas/instruction-mapping.schema.json",
  "isa": "RV32I",
  "version": "1.0.0",
  "spec_reference": "https://github.com/riscv/riscv-isa-manual/releases/download/riscv-isa-release-98ea4b5-2025-11-05/riscv-unprivileged.html",
  "instructions": {
    "LUI": {
      "format": "U-type",
      "encoding": {
        "opcode": "0b0110111",
        "rd": "bits 11:7",
        "imm": "bits 31:12 (upper 20 bits)",
        "full_encoding": "imm[31:12] | rd[11:7] | 0110111"
      },
      "assembly_syntax": "rd, imm",
      "description": "Load Upper Immediate - places the 20-bit immediate into bits 31:12 of rd, zeroing bits 11:0",
      "comment": "LUI (load upper immediate) is used to build 32-bit constants and uses the U-type format. LUI places the 20-bit U-immediate into bits 31â€“12 of register rd and places zero in the lowest 12 bits.",
      "spec_section": "2.4.1",
      "operation": "rd = imm << 12"
    },
    "AUIPC": {
      "format": "U-type",
      "encoding": {
        "opcode": "0b0010111",
        "rd": "bits 11:7",
        "imm": "bits 31:12 (upper 20 bits)",
        "full_encoding": "imm[31:12] | rd[11:7] | 0010111"
      },
      "assembly_syntax": "rd, imm",
      "description": "Add Upper Immediate to PC - forms a 32-bit offset and adds it to the PC",
      "comment": "AUIPC (add upper immediate to pc) is used to build pc-relative addresses and uses the U-type format. AUIPC forms a 32-bit offset from the 20-bit U-immediate, filling in the lowest 12 bits with zeros, adds this offset to the address of the AUIPC instruction, then places the result in register rd.",
      "spec_section": "2.4.1",
      "operation": "rd = pc + (imm << 12)"
    },
    "JAL": {
      "format": "J-type",
      "encoding": {
        "opcode": "0b1101111",
        "rd": "bits 11:7",
        "imm": "bits 31:12 encoded as imm[20|10:1|11|19:12]",
        "full_encoding": "imm[20|10:1|11|19:12] | rd[11:7] | 1101111"
      },
      "assembly_syntax": "rd, offset",
      "description": "Jump and Link - jumps to PC+offset and stores return address in rd",
      "comment": "The jump and link (JAL) instruction uses the J-type format, where the J-immediate encodes a signed offset in multiples of 2 bytes. The offset is sign-extended and added to the address of the jump instruction to form the jump target address. JAL stores the address of the instruction following the jump (pc+4) into register rd.",
      "spec_section": "2.5.1",
      "operation": "rd = pc + 4; pc = pc + sext(imm)"
    },
    "JALR": {
      "format": "I-type",
      "encoding": {
        "opcode": "0b1100111",
        "funct3": "0b000",
        "rd": "bits 11:7",
        "rs1": "bits 19:15",
        "imm": "bits 31:20 (12-bit signed)",
        "full_encoding": "imm[11:0] | rs1[19:15] | 000 | rd[11:7] | 1100111"
      },
      "assembly_syntax": "rd, rs1, offset",
      "description": "Jump and Link Register - jumps to rs1+offset and stores return address in rd",
      "comment": "The indirect jump instruction JALR (jump and link register) uses the I-type encoding. The target address is obtained by adding the sign-extended 12-bit I-immediate to the register rs1, then setting the least-significant bit of the result to zero. The address of the instruction following the jump (pc+4) is written to register rd.",
      "spec_section": "2.5.1",
      "operation": "rd = pc + 4; pc = (rs1 + sext(imm)) & ~1"
    },
    "BEQ": {
      "format": "B-type",
      "encoding": {
        "opcode": "0b1100011",
        "funct3": "0b000",
        "rs1": "bits 19:15",
        "rs2": "bits 24:20",
        "imm": "bits 31:25,11:7 encoded as imm[12|10:5|4:1|11]",
        "full_encoding": "imm[12|10:5] | rs2[24:20] | rs1[19:15] | 000 | imm[4:1|11] | 1100011"
      },
      "assembly_syntax": "rs1, rs2, offset",
      "description": "Branch if Equal - branches to PC+offset if rs1 equals rs2",
      "comment": "BEQ and BNE take the branch if registers rs1 and rs2 are equal or unequal respectively.",
      "spec_section": "2.5.2",
      "operation": "if (rs1 == rs2) pc = pc + sext(imm)"
    },
    "BNE": {
      "format": "B-type",
      "encoding": {
        "opcode": "0b1100011",
        "funct3": "0b001",
        "rs1": "bits 19:15",
        "rs2": "bits 24:20",
        "imm": "bits 31:25,11:7 encoded as imm[12|10:5|4:1|11]",
        "full_encoding": "imm[12|10:5] | rs2[24:20] | rs1[19:15] | 001 | imm[4:1|11] | 1100011"
      },
      "assembly_syntax": "rs1, rs2, offset",
      "description": "Branch if Not Equal - branches to PC+offset if rs1 does not equal rs2",
      "comment": "BEQ and BNE take the branch if registers rs1 and rs2 are equal or unequal respectively.",
      "spec_section": "2.5.2",
      "operation": "if (rs1 != rs2) pc = pc + sext(imm)"
    },
    "BLT": {
      "format": "B-type",
      "encoding": {
        "opcode": "0b1100011",
        "funct3": "0b100",
        "rs1": "bits 19:15",
        "rs2": "bits 24:20",
        "imm": "bits 31:25,11:7 encoded as imm[12|10:5|4:1|11]",
        "full_encoding": "imm[12|10:5] | rs2[24:20] | rs1[19:15] | 100 | imm[4:1|11] | 1100011"
      },
      "assembly_syntax": "rs1, rs2, offset",
      "description": "Branch if Less Than - branches if rs1 is less than rs2 (signed comparison)",
      "comment": "BLT and BLTU take the branch if rs1 is less than rs2, using signed and unsigned comparison respectively.",
      "spec_section": "2.5.2",
      "operation": "if (signed(rs1) < signed(rs2)) pc = pc + sext(imm)"
    },
    "BGE": {
      "format": "B-type",
      "encoding": {
        "opcode": "0b1100011",
        "funct3": "0b101",
        "rs1": "bits 19:15",
        "rs2": "bits 24:20",
        "imm": "bits 31:25,11:7 encoded as imm[12|10:5|4:1|11]",
        "full_encoding": "imm[12|10:5] | rs2[24:20] | rs1[19:15] | 101 | imm[4:1|11] | 1100011"
      },
      "assembly_syntax": "rs1, rs2, offset",
      "description": "Branch if Greater or Equal - branches if rs1 >= rs2 (signed comparison)",
      "comment": "BGE and BGEU take the branch if rs1 is greater than or equal to rs2, using signed and unsigned comparison respectively.",
      "spec_section": "2.5.2",
      "operation": "if (signed(rs1) >= signed(rs2)) pc = pc + sext(imm)"
    },
    "BLTU": {
      "format": "B-type",
      "encoding": {
        "opcode": "0b1100011",
        "funct3": "0b110",
        "rs1": "bits 19:15",
        "rs2": "bits 24:20",
        "imm": "bits 31:25,11:7 encoded as imm[12|10:5|4:1|11]",
        "full_encoding": "imm[12|10:5] | rs2[24:20] | rs1[19:15] | 110 | imm[4:1|11] | 1100011"
      },
      "assembly_syntax": "rs1, rs2, offset",
      "description": "Branch if Less Than Unsigned - branches if rs1 < rs2 (unsigned comparison)",
      "comment": "BLT and BLTU take the branch if rs1 is less than rs2, using signed and unsigned comparison respectively.",
      "spec_section": "2.5.2",
      "operation": "if (unsigned(rs1) < unsigned(rs2)) pc = pc + sext(imm)"
    },
    "BGEU": {
      "format": "B-type",
      "encoding": {
        "opcode": "0b1100011",
        "funct3": "0b111",
        "rs1": "bits 19:15",
        "rs2": "bits 24:20",
        "imm": "bits 31:25,11:7 encoded as imm[12|10:5|4:1|11]",
        "full_encoding": "imm[12|10:5] | rs2[24:20] | rs1[19:15] | 111 | imm[4:1|11] | 1100011"
      },
      "assembly_syntax": "rs1, rs2, offset",
      "description": "Branch if Greater or Equal Unsigned - branches if rs1 >= rs2 (unsigned comparison)",
      "comment": "BGE and BGEU take the branch if rs1 is greater than or equal to rs2, using signed and unsigned comparison respectively.",
      "spec_section": "2.5.2",
      "operation": "if (unsigned(rs1) >= unsigned(rs2)) pc = pc + sext(imm)"
    },
    "LB": {
      "format": "I-type",
      "encoding": {
        "opcode": "0b0000011",
        "funct3": "0b000",
        "rd": "bits 11:7",
        "rs1": "bits 19:15",
        "imm": "bits 31:20 (12-bit signed offset)",
        "full_encoding": "imm[11:0] | rs1[19:15] | 000 | rd[11:7] | 0000011"
      },
      "assembly_syntax": "rd, offset(rs1)",
      "description": "Load Byte - loads an 8-bit value from memory, sign-extends to XLEN",
      "comment": "The LB and LBU instructions load an 8-bit value from memory. LB then sign-extends to XLEN bits before storing in rd.",
      "spec_section": "2.6",
      "operation": "rd = sext(mem[rs1 + sext(imm)][7:0])"
    },
    "LH": {
      "format": "I-type",
      "encoding": {
        "opcode": "0b0000011",
        "funct3": "0b001",
        "rd": "bits 11:7",
        "rs1": "bits 19:15",
        "imm": "bits 31:20 (12-bit signed offset)",
        "full_encoding": "imm[11:0] | rs1[19:15] | 001 | rd[11:7] | 0000011"
      },
      "assembly_syntax": "rd, offset(rs1)",
      "description": "Load Halfword - loads a 16-bit value from memory, sign-extends to XLEN",
      "comment": "The LH and LHU instructions load a 16-bit value from memory. LH then sign-extends to XLEN bits before storing in rd.",
      "spec_section": "2.6",
      "operation": "rd = sext(mem[rs1 + sext(imm)][15:0])"
    },
    "LW": {
      "format": "I-type",
      "encoding": {
        "opcode": "0b0000011",
        "funct3": "0b010",
        "rd": "bits 11:7",
        "rs1": "bits 19:15",
        "imm": "bits 31:20 (12-bit signed offset)",
        "full_encoding": "imm[11:0] | rs1[19:15] | 010 | rd[11:7] | 0000011"
      },
      "assembly_syntax": "rd, offset(rs1)",
      "description": "Load Word - loads a 32-bit value from memory",
      "comment": "The LW instruction loads a 32-bit value from memory into rd. For RV64I, the 32-bit value is sign-extended to 64 bits before being stored in rd.",
      "spec_section": "2.6",
      "operation": "rd = sext(mem[rs1 + sext(imm)][31:0])"
    },
    "LBU": {
      "format": "I-type",
      "encoding": {
        "opcode": "0b0000011",
        "funct3": "0b100",
        "rd": "bits 11:7",
        "rs1": "bits 19:15",
        "imm": "bits 31:20 (12-bit signed offset)",
        "full_encoding": "imm[11:0] | rs1[19:15] | 100 | rd[11:7] | 0000011"
      },
      "assembly_syntax": "rd, offset(rs1)",
      "description": "Load Byte Unsigned - loads an 8-bit value from memory, zero-extends to XLEN",
      "comment": "The LB and LBU instructions load an 8-bit value from memory. LBU then zero-extends to XLEN bits before storing in rd.",
      "spec_section": "2.6",
      "operation": "rd = zext(mem[rs1 + sext(imm)][7:0])"
    },
    "LHU": {
      "format": "I-type",
      "encoding": {
        "opcode": "0b0000011",
        "funct3": "0b101",
        "rd": "bits 11:7",
        "rs1": "bits 19:15",
        "imm": "bits 31:20 (12-bit signed offset)",
        "full_encoding": "imm[11:0] | rs1[19:15] | 101 | rd[11:7] | 0000011"
      },
      "assembly_syntax": "rd, offset(rs1)",
      "description": "Load Halfword Unsigned - loads a 16-bit value from memory, zero-extends to XLEN",
      "comment": "The LH and LHU instructions load a 16-bit value from memory. LHU then zero-extends to XLEN bits before storing in rd.",
      "spec_section": "2.6",
      "operation": "rd = zext(mem[rs1 + sext(imm)][15:0])"
    },
    "SB": {
      "format": "S-type",
      "encoding": {
        "opcode": "0b0100011",
        "funct3": "0b000",
        "rs1": "bits 19:15 (base address)",
        "rs2": "bits 24:20 (source data)",
        "imm": "bits 31:25,11:7 (12-bit signed offset)",
        "full_encoding": "imm[11:5] | rs2[24:20] | rs1[19:15] | 000 | imm[4:0] | 0100011"
      },
      "assembly_syntax": "rs2, offset(rs1)",
      "description": "Store Byte - stores the low 8 bits of rs2 to memory",
      "comment": "The SB, SH, and SW instructions store 8-bit, 16-bit, and 32-bit values from the low bits of register rs2 to memory.",
      "spec_section": "2.6",
      "operation": "mem[rs1 + sext(imm)] = rs2[7:0]"
    },
    "SH": {
      "format": "S-type",
      "encoding": {
        "opcode": "0b0100011",
        "funct3": "0b001",
        "rs1": "bits 19:15 (base address)",
        "rs2": "bits 24:20 (source data)",
        "imm": "bits 31:25,11:7 (12-bit signed offset)",
        "full_encoding": "imm[11:5] | rs2[24:20] | rs1[19:15] | 001 | imm[4:0] | 0100011"
      },
      "assembly_syntax": "rs2, offset(rs1)",
      "description": "Store Halfword - stores the low 16 bits of rs2 to memory",
      "comment": "The SB, SH, and SW instructions store 8-bit, 16-bit, and 32-bit values from the low bits of register rs2 to memory.",
      "spec_section": "2.6",
      "operation": "mem[rs1 + sext(imm)] = rs2[15:0]"
    },
    "SW": {
      "format": "S-type",
      "encoding": {
        "opcode": "0b0100011",
        "funct3": "0b010",
        "rs1": "bits 19:15 (base address)",
        "rs2": "bits 24:20 (source data)",
        "imm": "bits 31:25,11:7 (12-bit signed offset)",
        "full_encoding": "imm[11:5] | rs2[24:20] | rs1[19:15] | 010 | imm[4:0] | 0100011"
      },
      "assembly_syntax": "rs2, offset(rs1)",
      "description": "Store Word - stores the low 32 bits of rs2 to memory",
      "comment": "The SB, SH, and SW instructions store 8-bit, 16-bit, and 32-bit values from the low bits of register rs2 to memory.",
      "spec_section": "2.6",
      "operation": "mem[rs1 + sext(imm)] = rs2[31:0]"
    },
    "ADDI": {
      "format": "I-type",
      "encoding": {
        "opcode": "0b0010011",
        "funct3": "0b000",
        "rd": "bits 11:7",
        "rs1": "bits 19:15",
        "imm": "bits 31:20 (12-bit signed immediate)",
        "full_encoding": "imm[11:0] | rs1[19:15] | 000 | rd[11:7] | 0010011"
      },
      "assembly_syntax": "rd, rs1, imm",
      "description": "Add Immediate - adds sign-extended 12-bit immediate to rs1",
      "comment": "ADDI adds the sign-extended 12-bit immediate to register rs1. Arithmetic overflow is ignored and the result is simply the low XLEN bits of the result. ADDI rd, rs1, 0 is used to implement the MV rd, rs1 assembler pseudoinstruction.",
      "spec_section": "2.4.1",
      "operation": "rd = rs1 + sext(imm)",
      "notes": ["NOP is encoded as ADDI x0, x0, 0"]
    },
    "SLTI": {
      "format": "I-type",
      "encoding": {
        "opcode": "0b0010011",
        "funct3": "0b010",
        "rd": "bits 11:7",
        "rs1": "bits 19:15",
        "imm": "bits 31:20 (12-bit signed immediate)",
        "full_encoding": "imm[11:0] | rs1[19:15] | 010 | rd[11:7] | 0010011"
      },
      "assembly_syntax": "rd, rs1, imm",
      "description": "Set Less Than Immediate - sets rd to 1 if rs1 < imm (signed), else 0",
      "comment": "SLTI (set less than immediate) places the value 1 in register rd if register rs1 is less than the sign-extended immediate when both are treated as signed numbers, else 0 is written to rd.",
      "spec_section": "2.4.1",
      "operation": "rd = (signed(rs1) < sext(imm)) ? 1 : 0"
    },
    "SLTIU": {
      "format": "I-type",
      "encoding": {
        "opcode": "0b0010011",
        "funct3": "0b011",
        "rd": "bits 11:7",
        "rs1": "bits 19:15",
        "imm": "bits 31:20 (12-bit signed immediate)",
        "full_encoding": "imm[11:0] | rs1[19:15] | 011 | rd[11:7] | 0010011"
      },
      "assembly_syntax": "rd, rs1, imm",
      "description": "Set Less Than Immediate Unsigned - sets rd to 1 if rs1 < imm (unsigned), else 0",
      "comment": "SLTIU (set less than immediate, unsigned) is similar but compares the values as unsigned numbers (i.e., the immediate is first sign-extended to XLEN bits then treated as an unsigned number). Note, SLTIU rd, rs1, 1 sets rd to 1 if rs1 equals zero, otherwise sets rd to 0 (assembler pseudoinstruction SEQZ rd, rs1).",
      "spec_section": "2.4.1",
      "operation": "rd = (unsigned(rs1) < unsigned(sext(imm))) ? 1 : 0"
    },
    "XORI": {
      "format": "I-type",
      "encoding": {
        "opcode": "0b0010011",
        "funct3": "0b100",
        "rd": "bits 11:7",
        "rs1": "bits 19:15",
        "imm": "bits 31:20 (12-bit signed immediate)",
        "full_encoding": "imm[11:0] | rs1[19:15] | 100 | rd[11:7] | 0010011"
      },
      "assembly_syntax": "rd, rs1, imm",
      "description": "XOR Immediate - bitwise XOR of rs1 and sign-extended immediate",
      "comment": "ANDI, ORI, XORI are logical operations that perform bitwise AND, OR, and XOR on register rs1 and the sign-extended 12-bit immediate and place the result in rd. Note, XORI rd, rs1, -1 performs a bitwise logical inversion of register rs1 (assembler pseudoinstruction NOT rd, rs1).",
      "spec_section": "2.4.1",
      "operation": "rd = rs1 ^ sext(imm)"
    },
    "ORI": {
      "format": "I-type",
      "encoding": {
        "opcode": "0b0010011",
        "funct3": "0b110",
        "rd": "bits 11:7",
        "rs1": "bits 19:15",
        "imm": "bits 31:20 (12-bit signed immediate)",
        "full_encoding": "imm[11:0] | rs1[19:15] | 110 | rd[11:7] | 0010011"
      },
      "assembly_syntax": "rd, rs1, imm",
      "description": "OR Immediate - bitwise OR of rs1 and sign-extended immediate",
      "comment": "ANDI, ORI, XORI are logical operations that perform bitwise AND, OR, and XOR on register rs1 and the sign-extended 12-bit immediate and place the result in rd.",
      "spec_section": "2.4.1",
      "operation": "rd = rs1 | sext(imm)"
    },
    "ANDI": {
      "format": "I-type",
      "encoding": {
        "opcode": "0b0010011",
        "funct3": "0b111",
        "rd": "bits 11:7",
        "rs1": "bits 19:15",
        "imm": "bits 31:20 (12-bit signed immediate)",
        "full_encoding": "imm[11:0] | rs1[19:15] | 111 | rd[11:7] | 0010011"
      },
      "assembly_syntax": "rd, rs1, imm",
      "description": "AND Immediate - bitwise AND of rs1 and sign-extended immediate",
      "comment": "ANDI, ORI, XORI are logical operations that perform bitwise AND, OR, and XOR on register rs1 and the sign-extended 12-bit immediate and place the result in rd.",
      "spec_section": "2.4.1",
      "operation": "rd = rs1 & sext(imm)"
    },
    "SLLI": {
      "format": "I-type",
      "encoding": {
        "opcode": "0b0010011",
        "funct3": "0b001",
        "funct7": "0b0000000",
        "rd": "bits 11:7",
        "rs1": "bits 19:15",
        "imm": "bits 24:20 (5-bit shift amount for RV32I)",
        "full_encoding": "0000000 | shamt[4:0] | rs1[19:15] | 001 | rd[11:7] | 0010011"
      },
      "assembly_syntax": "rd, rs1, shamt",
      "description": "Shift Left Logical Immediate - shifts rs1 left by shamt bits",
      "comment": "SLLI is a logical left shift (zeros are shifted into the lower bits). Shifts by a constant are encoded as a specialization of the I-type format. The operand to be shifted is in rs1, and the shift amount is encoded in the lower 5 bits of the I-immediate field.",
      "spec_section": "2.4.1",
      "operation": "rd = rs1 << shamt"
    },
    "SRLI": {
      "format": "I-type",
      "encoding": {
        "opcode": "0b0010011",
        "funct3": "0b101",
        "funct7": "0b0000000",
        "rd": "bits 11:7",
        "rs1": "bits 19:15",
        "imm": "bits 24:20 (5-bit shift amount for RV32I)",
        "full_encoding": "0000000 | shamt[4:0] | rs1[19:15] | 101 | rd[11:7] | 0010011"
      },
      "assembly_syntax": "rd, rs1, shamt",
      "description": "Shift Right Logical Immediate - shifts rs1 right by shamt bits (zero-fill)",
      "comment": "SRLI is a logical right shift (zeros are shifted into the upper bits). The shift amount is held in the lower 5 bits of the I-immediate field for RV32I.",
      "spec_section": "2.4.1",
      "operation": "rd = rs1 >> shamt (logical)"
    },
    "SRAI": {
      "format": "I-type",
      "encoding": {
        "opcode": "0b0010011",
        "funct3": "0b101",
        "funct7": "0b0100000",
        "rd": "bits 11:7",
        "rs1": "bits 19:15",
        "imm": "bits 24:20 (5-bit shift amount for RV32I)",
        "full_encoding": "0100000 | shamt[4:0] | rs1[19:15] | 101 | rd[11:7] | 0010011"
      },
      "assembly_syntax": "rd, rs1, shamt",
      "description": "Shift Right Arithmetic Immediate - shifts rs1 right by shamt bits (sign-fill)",
      "comment": "SRAI is an arithmetic right shift (the original sign bit is copied into the vacated upper bits). SRAI is differentiated from SRLI by the upper bit of the shift amount (bit 30 of the instruction) being set to 1.",
      "spec_section": "2.4.1",
      "operation": "rd = rs1 >> shamt (arithmetic)"
    },
    "ADD": {
      "format": "R-type",
      "encoding": {
        "opcode": "0b0110011",
        "funct3": "0b000",
        "funct7": "0b0000000",
        "rd": "bits 11:7",
        "rs1": "bits 19:15",
        "rs2": "bits 24:20",
        "full_encoding": "0000000 | rs2[24:20] | rs1[19:15] | 000 | rd[11:7] | 0110011"
      },
      "assembly_syntax": "rd, rs1, rs2",
      "description": "Add - adds rs1 and rs2",
      "comment": "ADD performs the addition of rs1 and rs2. Overflows are ignored and the low XLEN bits of the results are written to the destination rd.",
      "spec_section": "2.4.2",
      "operation": "rd = rs1 + rs2"
    },
    "SUB": {
      "format": "R-type",
      "encoding": {
        "opcode": "0b0110011",
        "funct3": "0b000",
        "funct7": "0b0100000",
        "rd": "bits 11:7",
        "rs1": "bits 19:15",
        "rs2": "bits 24:20",
        "full_encoding": "0100000 | rs2[24:20] | rs1[19:15] | 000 | rd[11:7] | 0110011"
      },
      "assembly_syntax": "rd, rs1, rs2",
      "description": "Subtract - subtracts rs2 from rs1",
      "comment": "SUB performs the subtraction of rs2 from rs1. Overflows are ignored and the low XLEN bits of the results are written to the destination rd.",
      "spec_section": "2.4.2",
      "operation": "rd = rs1 - rs2"
    },
    "SLL": {
      "format": "R-type",
      "encoding": {
        "opcode": "0b0110011",
        "funct3": "0b001",
        "funct7": "0b0000000",
        "rd": "bits 11:7",
        "rs1": "bits 19:15",
        "rs2": "bits 24:20",
        "full_encoding": "0000000 | rs2[24:20] | rs1[19:15] | 001 | rd[11:7] | 0110011"
      },
      "assembly_syntax": "rd, rs1, rs2",
      "description": "Shift Left Logical - shifts rs1 left by the amount in rs2[4:0]",
      "comment": "SLL, SRL, and SRA perform logical left, logical right, and arithmetic right shifts on the value in register rs1 by the shift amount held in the lower 5 bits of register rs2.",
      "spec_section": "2.4.2",
      "operation": "rd = rs1 << rs2[4:0]"
    },
    "SLT": {
      "format": "R-type",
      "encoding": {
        "opcode": "0b0110011",
        "funct3": "0b010",
        "funct7": "0b0000000",
        "rd": "bits 11:7",
        "rs1": "bits 19:15",
        "rs2": "bits 24:20",
        "full_encoding": "0000000 | rs2[24:20] | rs1[19:15] | 010 | rd[11:7] | 0110011"
      },
      "assembly_syntax": "rd, rs1, rs2",
      "description": "Set Less Than - sets rd to 1 if rs1 < rs2 (signed), else 0",
      "comment": "SLT and SLTU perform signed and unsigned compares respectively, writing 1 to rd if rs1 < rs2, 0 otherwise.",
      "spec_section": "2.4.2",
      "operation": "rd = (signed(rs1) < signed(rs2)) ? 1 : 0"
    },
    "SLTU": {
      "format": "R-type",
      "encoding": {
        "opcode": "0b0110011",
        "funct3": "0b011",
        "funct7": "0b0000000",
        "rd": "bits 11:7",
        "rs1": "bits 19:15",
        "rs2": "bits 24:20",
        "full_encoding": "0000000 | rs2[24:20] | rs1[19:15] | 011 | rd[11:7] | 0110011"
      },
      "assembly_syntax": "rd, rs1, rs2",
      "description": "Set Less Than Unsigned - sets rd to 1 if rs1 < rs2 (unsigned), else 0",
      "comment": "SLT and SLTU perform signed and unsigned compares respectively, writing 1 to rd if rs1 < rs2, 0 otherwise. Note, SLTU rd, x0, rs2 sets rd to 1 if rs2 is not equal to zero, otherwise sets rd to zero (assembler pseudoinstruction SNEZ rd, rs2).",
      "spec_section": "2.4.2",
      "operation": "rd = (unsigned(rs1) < unsigned(rs2)) ? 1 : 0"
    },
    "XOR": {
      "format": "R-type",
      "encoding": {
        "opcode": "0b0110011",
        "funct3": "0b100",
        "funct7": "0b0000000",
        "rd": "bits 11:7",
        "rs1": "bits 19:15",
        "rs2": "bits 24:20",
        "full_encoding": "0000000 | rs2[24:20] | rs1[19:15] | 100 | rd[11:7] | 0110011"
      },
      "assembly_syntax": "rd, rs1, rs2",
      "description": "XOR - bitwise XOR of rs1 and rs2",
      "comment": "AND, OR, and XOR perform bitwise logical operations.",
      "spec_section": "2.4.2",
      "operation": "rd = rs1 ^ rs2"
    },
    "SRL": {
      "format": "R-type",
      "encoding": {
        "opcode": "0b0110011",
        "funct3": "0b101",
        "funct7": "0b0000000",
        "rd": "bits 11:7",
        "rs1": "bits 19:15",
        "rs2": "bits 24:20",
        "full_encoding": "0000000 | rs2[24:20] | rs1[19:15] | 101 | rd[11:7] | 0110011"
      },
      "assembly_syntax": "rd, rs1, rs2",
      "description": "Shift Right Logical - shifts rs1 right by rs2[4:0] bits (zero-fill)",
      "comment": "SLL, SRL, and SRA perform logical left, logical right, and arithmetic right shifts on the value in register rs1 by the shift amount held in the lower 5 bits of register rs2.",
      "spec_section": "2.4.2",
      "operation": "rd = rs1 >> rs2[4:0] (logical)"
    },
    "SRA": {
      "format": "R-type",
      "encoding": {
        "opcode": "0b0110011",
        "funct3": "0b101",
        "funct7": "0b0100000",
        "rd": "bits 11:7",
        "rs1": "bits 19:15",
        "rs2": "bits 24:20",
        "full_encoding": "0100000 | rs2[24:20] | rs1[19:15] | 101 | rd[11:7] | 0110011"
      },
      "assembly_syntax": "rd, rs1, rs2",
      "description": "Shift Right Arithmetic - shifts rs1 right by rs2[4:0] bits (sign-fill)",
      "comment": "SLL, SRL, and SRA perform logical left, logical right, and arithmetic right shifts on the value in register rs1 by the shift amount held in the lower 5 bits of register rs2.",
      "spec_section": "2.4.2",
      "operation": "rd = rs1 >> rs2[4:0] (arithmetic)"
    },
    "OR": {
      "format": "R-type",
      "encoding": {
        "opcode": "0b0110011",
        "funct3": "0b110",
        "funct7": "0b0000000",
        "rd": "bits 11:7",
        "rs1": "bits 19:15",
        "rs2": "bits 24:20",
        "full_encoding": "0000000 | rs2[24:20] | rs1[19:15] | 110 | rd[11:7] | 0110011"
      },
      "assembly_syntax": "rd, rs1, rs2",
      "description": "OR - bitwise OR of rs1 and rs2",
      "comment": "AND, OR, and XOR perform bitwise logical operations.",
      "spec_section": "2.4.2",
      "operation": "rd = rs1 | rs2"
    },
    "AND": {
      "format": "R-type",
      "encoding": {
        "opcode": "0b0110011",
        "funct3": "0b111",
        "funct7": "0b0000000",
        "rd": "bits 11:7",
        "rs1": "bits 19:15",
        "rs2": "bits 24:20",
        "full_encoding": "0000000 | rs2[24:20] | rs1[19:15] | 111 | rd[11:7] | 0110011"
      },
      "assembly_syntax": "rd, rs1, rs2",
      "description": "AND - bitwise AND of rs1 and rs2",
      "comment": "AND, OR, and XOR perform bitwise logical operations.",
      "spec_section": "2.4.2",
      "operation": "rd = rs1 & rs2"
    },
    "FENCE": {
      "format": "I-type",
      "encoding": {
        "opcode": "0b0001111",
        "funct3": "0b000",
        "rd": "bits 11:7 (ignored, should be 0)",
        "rs1": "bits 19:15 (ignored, should be 0)",
        "imm": "bits 31:20 (fm, pred, succ fields)",
        "full_encoding": "fm[3:0] | pred[3:0] | succ[3:0] | 00000 | 000 | 00000 | 0001111"
      },
      "assembly_syntax": "pred, succ",
      "description": "Memory Fence - orders memory operations",
      "comment": "The FENCE instruction is used to order device I/O and memory accesses as viewed by other RISC-V harts and external devices or coprocessors. Any combination of device input (I), device output (O), memory reads (R), and memory writes (W) may be ordered with respect to any combination of the same.",
      "spec_section": "2.7",
      "operation": "fence(pred, succ)"
    },
    "ECALL": {
      "format": "I-type",
      "encoding": {
        "opcode": "0b1110011",
        "funct3": "0b000",
        "rd": "00000",
        "rs1": "00000",
        "imm": "000000000000",
        "full_encoding": "000000000000 | 00000 | 000 | 00000 | 1110011"
      },
      "assembly_syntax": "",
      "description": "Environment Call - makes a service request to the execution environment",
      "comment": "The ECALL instruction is used to make a service request to the execution environment. The EEI will define how parameters for the service request are passed, but usually these will be in defined locations in the integer register file.",
      "spec_section": "2.8",
      "operation": "raise environment-call exception"
    },
    "EBREAK": {
      "format": "I-type",
      "encoding": {
        "opcode": "0b1110011",
        "funct3": "0b000",
        "rd": "00000",
        "rs1": "00000",
        "imm": "000000000001",
        "full_encoding": "000000000001 | 00000 | 000 | 00000 | 1110011"
      },
      "assembly_syntax": "",
      "description": "Environment Breakpoint - causes a breakpoint exception",
      "comment": "The EBREAK instruction is used to return control to a debugging environment. The EBREAK instruction is used by debuggers to cause control to be transferred back to a debugging environment.",
      "spec_section": "2.8",
      "operation": "raise breakpoint exception"
    },
    "NOP": {
      "format": "I-type",
      "encoding": {
        "opcode": "0b0010011",
        "funct3": "0b000",
        "rd": "00000",
        "rs1": "00000",
        "imm": "000000000000",
        "full_encoding": "000000000000 | 00000 | 000 | 00000 | 0010011"
      },
      "assembly_syntax": "",
      "description": "No Operation - encoded as ADDI x0, x0, 0",
      "comment": "The NOP instruction does not change any user-visible state, except for advancing the pc and incrementing any applicable performance counters. NOP is encoded as ADDI x0, x0, 0.",
      "spec_section": "2.4.3",
      "operation": "no operation"
    }
  }
}
