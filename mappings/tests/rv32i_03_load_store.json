{
  "$schema": "../../schemas/test-mapping.schema.json",
  "test_file": "rv32i/03_load_store.s",
  "isa": "RV32I",
  "version": "1.0.0",
  "spec_reference": "https://github.com/riscv/riscv-isa-manual/releases/download/riscv-isa-release-98ea4b5-2025-11-05/riscv-unprivileged.html",
  "description": "Tests RV32I load and store instructions for bytes, halfwords, and words with sign/zero extension",
  "test_cases": [
    {
      "name": "LW load word",
      "line_range": {"start": 17, "end": 20},
      "instructions": ["LW"],
      "initial_state": {
        "memory": {
          "test_data+0": "0x12345678",
          "test_data+4": "0x9ABCDEF0"
        }
      },
      "expected_behavior": {
        "registers": {
          "t0": "0x12345678",
          "t1": "0x9ABCDEF0"
        }
      },
      "comment": "LW loads a 32-bit value from memory into rd. The effective address is obtained by adding register rs1 to the sign-extended 12-bit offset.",
      "spec_section": "2.6",
      "python_verification": "t0 = 0x12345678; t1 = 0x9ABCDEF0"
    },
    {
      "name": "LH load halfword sign-extended",
      "line_range": {"start": 22, "end": 25},
      "instructions": ["LH"],
      "initial_state": {
        "memory": {
          "test_data+0": "0x5678 (low halfword of 0x12345678)"
        }
      },
      "expected_behavior": {
        "registers": {
          "t2": "0x00005678",
          "t3": "0x00001234"
        }
      },
      "comment": "LH loads a 16-bit value from memory, then sign-extends to 32-bits before storing in rd.",
      "spec_section": "2.6",
      "python_verification": "import ctypes; hw = 0x5678; t2 = ctypes.c_int16(hw).value if hw & 0x8000 else hw  # Sign extend if MSB set"
    },
    {
      "name": "LHU load halfword zero-extended",
      "line_range": {"start": 27, "end": 28},
      "instructions": ["LHU"],
      "expected_behavior": {
        "registers": {
          "t4": "0x00005678"
        }
      },
      "comment": "LHU loads a 16-bit value from memory but zero extends to 32 bits.",
      "spec_section": "2.6",
      "python_verification": "t4 = 0x5678  # Zero extended, always positive"
    },
    {
      "name": "LB load byte sign-extended",
      "line_range": {"start": 30, "end": 32},
      "instructions": ["LB"],
      "expected_behavior": {
        "registers": {
          "t5": "0x00000078 or 0xFFFFFF78 depending on byte value",
          "t6": "0x00000056 or 0xFFFFFF56 depending on byte value"
        }
      },
      "comment": "LB loads an 8-bit value from memory, then sign-extends to 32-bits.",
      "spec_section": "2.6",
      "python_verification": "import ctypes; byte_val = 0x78; t5 = ctypes.c_int8(byte_val).value if byte_val & 0x80 else byte_val"
    },
    {
      "name": "LBU load byte zero-extended",
      "line_range": {"start": 34, "end": 35},
      "instructions": ["LBU"],
      "expected_behavior": {
        "registers": {
          "a0": "0x00000078"
        }
      },
      "comment": "LBU loads an 8-bit value from memory but zero extends to 32 bits.",
      "spec_section": "2.6"
    },
    {
      "name": "SW store word",
      "line_range": {"start": 44, "end": 46},
      "instructions": ["SW"],
      "initial_state": {
        "registers": {"a1": "0x12345678"}
      },
      "expected_behavior": {
        "memory": {
          "store_area+0": "0x12345678"
        }
      },
      "comment": "SW, SH, and SB store 32-bit, 16-bit, and 8-bit values from the low bits of register rs2 to memory. The effective address is obtained by adding register rs1 to the sign-extended 12-bit offset.",
      "spec_section": "2.6"
    },
    {
      "name": "SH store halfword",
      "line_range": {"start": 48, "end": 50},
      "instructions": ["SH"],
      "initial_state": {
        "registers": {"a2": "0xABCD"}
      },
      "expected_behavior": {
        "memory": {
          "store_area+4": "0xABCD (low 16 bits)"
        }
      },
      "comment": "SW, SH, and SB store 32-bit, 16-bit, and 8-bit values from the low bits of register rs2 to memory.",
      "spec_section": "2.6"
    },
    {
      "name": "SB store byte",
      "line_range": {"start": 52, "end": 54},
      "instructions": ["SB"],
      "initial_state": {
        "registers": {"a3": "0xEF"}
      },
      "expected_behavior": {
        "memory": {
          "store_area+6": "0xEF (low 8 bits)"
        }
      },
      "comment": "SW, SH, and SB store 32-bit, 16-bit, and 8-bit values from the low bits of register rs2 to memory.",
      "spec_section": "2.6"
    },
    {
      "name": "Verify stores with different load widths",
      "line_range": {"start": 56, "end": 61},
      "instructions": ["LW", "LH", "LHU", "LB", "LBU"],
      "expected_behavior": {
        "registers": {
          "a4": "0x12345678",
          "a5": "0xFFFFABCD",
          "a6": "0x0000ABCD",
          "a7": "0xFFFFFFEF",
          "s2": "0x000000EF"
        }
      },
      "comment": "The LB and LBU instructions load an 8-bit value from memory. LB then sign-extends to XLEN bits before storing in rd. LBU then zero-extends to XLEN bits before storing in rd.",
      "spec_section": "2.6",
      "python_verification": "a5 = 0xFFFFABCD  # 0xABCD sign-extended (bit 15 is 1); a6 = 0x0000ABCD  # zero-extended; a7 = 0xFFFFFFEF  # 0xEF sign-extended (bit 7 is 1); s2 = 0x000000EF  # zero-extended",
      "notes": ["Sign extension copies the MSB of the loaded value to fill upper bits"]
    },
    {
      "name": "Negative offset loads",
      "line_range": {"start": 63, "end": 67},
      "instructions": ["LW"],
      "expected_behavior": {
        "registers": {
          "s4": "value at middle_data-4",
          "s5": "value at middle_data",
          "s6": "value at middle_data+4"
        }
      },
      "comment": "The effective address is obtained by adding register rs1 to the sign-extended 12-bit offset.",
      "spec_section": "2.6",
      "notes": ["Offset can be negative (-2048 to +2047)"]
    },
    {
      "name": "Sign extension boundary - 0xFF byte",
      "line_range": {"start": 69, "end": 73},
      "instructions": ["SB", "LB", "LBU"],
      "initial_state": {
        "registers": {"t0": 255}
      },
      "expected_behavior": {
        "registers": {
          "t1": -1,
          "t2": 255
        }
      },
      "comment": "LB loads an 8-bit value from memory, then sign-extends to 32-bits. LBU zero extends to 32 bits.",
      "spec_section": "2.6",
      "python_verification": "byte_val = 0xFF; t1 = -1  # LB sign extends 0xFF to 0xFFFFFFFF = -1; t2 = 255  # LBU zero extends to 0x000000FF = 255",
      "edge_case": true
    },
    {
      "name": "Store zero register",
      "line_range": {"start": 75, "end": 77},
      "instructions": ["SW", "LW"],
      "expected_behavior": {
        "registers": {
          "s7": 0
        }
      },
      "comment": "Register x0 is hardwired with all bits equal to 0. Reads from x0 always return 0.",
      "spec_section": "2.1",
      "notes": ["x0 (zero) always reads as 0"]
    }
  ]
}
