{
  "$schema": "../../schemas/test-mapping.schema.json",
  "test_file": "rv32i/04_edge_cases.s",
  "isa": "RV32I",
  "version": "1.0.0",
  "spec_reference": "https://github.com/riscv/riscv-isa-manual/releases/download/riscv-isa-release-98ea4b5-2025-11-05/riscv-unprivileged.html",
  "description": "Tests edge cases and boundary conditions for RV32I including overflow, underflow, maximum values, and special register behavior. HINT instructions (addi x0, x0, N) mark test case N.",
  "test_cases": [
    {
      "name": "Integer overflow with ADDI",
      "hint_marker": 1,
      "instructions": ["ADDI"],
      "initial_state": {
        "registers": {"t0": "0x7FFFFFFF"}
      },
      "expected_behavior": {
        "registers": {
          "t1": "0x80000000"
        }
      },
      "comment": "Arithmetic overflow is ignored and the result is simply the low XLEN bits of the result.",
      "spec_section": "2.4.1",
      "python_verification": "t0 = 0x7FFFFFFF; t1 = (t0 + 1) & 0xFFFFFFFF  # t1 = 0x80000000",
      "edge_case": true,
      "notes": ["MAX_INT32 + 1 wraps to MIN_INT32"]
    },
    {
      "name": "Integer underflow with ADDI",
      "hint_marker": 2,
      "instructions": ["ADDI"],
      "initial_state": {
        "registers": {"t2": "0x80000000"}
      },
      "expected_behavior": {
        "registers": {
          "t3": "0x7FFFFFFF"
        }
      },
      "comment": "Arithmetic overflow is ignored and the result is simply the low XLEN bits of the result.",
      "spec_section": "2.4.1",
      "python_verification": "t2 = 0x80000000; t3 = (t2 - 1) & 0xFFFFFFFF  # t3 = 0x7FFFFFFF",
      "edge_case": true,
      "notes": ["MIN_INT32 - 1 wraps to MAX_INT32"]
    },
    {
      "name": "ADD overflow with two MAX_INT",
      "hint_marker": 3,
      "instructions": ["ADD"],
      "initial_state": {
        "registers": {"a0": "0x7FFFFFFF", "a1": "0x7FFFFFFF"}
      },
      "expected_behavior": {
        "registers": {
          "a2": "0xFFFFFFFE"
        }
      },
      "comment": "Overflows are ignored and the low XLEN bits of the results are written to the destination rd.",
      "spec_section": "2.4.2",
      "python_verification": "a0 = 0x7FFFFFFF; a1 = 0x7FFFFFFF; a2 = (a0 + a1) & 0xFFFFFFFF  # a2 = 0xFFFFFFFE = -2 signed",
      "edge_case": true
    },
    {
      "name": "SUB underflow from MIN_INT",
      "hint_marker": 4,
      "instructions": ["SUB"],
      "initial_state": {
        "registers": {"a3": "0x80000000", "a4": 1}
      },
      "expected_behavior": {
        "registers": {
          "a5": "0x7FFFFFFF"
        }
      },
      "comment": "Overflows are ignored and the low XLEN bits of the results are written to the destination rd.",
      "spec_section": "2.4.2",
      "python_verification": "a3 = 0x80000000; a4 = 1; a5 = (a3 - a4) & 0xFFFFFFFF  # a5 = 0x7FFFFFFF",
      "edge_case": true
    },
    {
      "name": "Zero register hardwired to 0",
      "hint_marker": 5,
      "instructions": ["ADD"],
      "initial_state": {
        "registers": {"t0": 42, "x0": 0}
      },
      "expected_behavior": {
        "registers": {
          "t1": 42,
          "t2": 42,
          "t3": 0
        }
      },
      "comment": "Register x0 is hardwired with all bits equal to 0.",
      "spec_section": "2.1",
      "notes": ["Reading from x0 always returns 0, writing to x0 is ignored"]
    },
    {
      "name": "Maximum shift amount (31)",
      "hint_marker": 6,
      "instructions": ["SRL", "SRA"],
      "initial_state": {
        "registers": {"s0": "0x80000000", "s1": 31}
      },
      "expected_behavior": {
        "registers": {
          "s2": 1,
          "s3": "0xFFFFFFFF"
        }
      },
      "comment": "SLL, SRL, and SRA perform logical left, logical right, and arithmetic right shifts on the value in register rs1 by the shift amount held in the lower 5 bits of register rs2.",
      "spec_section": "2.4.2",
      "python_verification": "s0 = 0x80000000; s1 = 31; s2 = s0 >> s1  # s2 = 1 (logical); import ctypes; s3 = ctypes.c_int32(s0).value >> s1  # s3 = -1 (arithmetic sign-fill)",
      "edge_case": true
    },
    {
      "name": "Shift by 0",
      "hint_marker": 7,
      "instructions": ["SLL"],
      "initial_state": {
        "registers": {"s4": "0x12345678", "s5": 0}
      },
      "expected_behavior": {
        "registers": {
          "s6": "0x12345678"
        }
      },
      "comment": "SLL, SRL, and SRA perform logical left, logical right, and arithmetic right shifts on the value in register rs1 by the shift amount held in the lower 5 bits of register rs2.",
      "spec_section": "2.4.2",
      "notes": ["Shifting by 0 leaves value unchanged"]
    },
    {
      "name": "Shift amount uses only lower 5 bits",
      "hint_marker": 8,
      "instructions": ["SLL"],
      "initial_state": {
        "registers": {"t4": "0xFFFFFFFF", "t5": 32, "a6": "0xFFFFFFFF", "a7": 33}
      },
      "expected_behavior": {
        "registers": {
          "t6": "0xFFFFFFFF",
          "s7": "0xFFFFFFFE"
        }
      },
      "comment": "SLL, SRL, and SRA perform logical left, logical right, and arithmetic right shifts on the value in register rs1 by the shift amount held in the lower 5 bits of register rs2.",
      "spec_section": "2.4.2",
      "python_verification": "t4 = 0xFFFFFFFF; t5 = 32; t6 = (t4 << (t5 & 0x1F)) & 0xFFFFFFFF  # t5&0x1F=0, t6=unchanged; a7 = 33; s7 = (0xFFFFFFFF << (a7 & 0x1F)) & 0xFFFFFFFF  # a7&0x1F=1, s7=0xFFFFFFFE",
      "edge_case": true,
      "notes": ["Shift amounts >= 32 are masked to 0-31"]
    },
    {
      "name": "SLTI boundary comparisons",
      "hint_marker": 9,
      "instructions": ["SLTI"],
      "initial_state": {
        "registers": {"t0": 0}
      },
      "expected_behavior": {
        "registers": {
          "t1": 1,
          "t2": 0,
          "t3": 0
        }
      },
      "comment": "SLTI (set less than immediate) places the value 1 in register rd if register rs1 is less than the sign-extended immediate when both are treated as signed numbers, else 0 is written to rd.",
      "spec_section": "2.4.1",
      "python_verification": "t0 = 0; t1 = 1 if t0 < 1 else 0; t2 = 1 if t0 < 0 else 0; t3 = 1 if t0 < -1 else 0  # t1=1, t2=0, t3=0"
    },
    {
      "name": "SLTU with max unsigned value",
      "hint_marker": 10,
      "instructions": ["SLTU"],
      "initial_state": {
        "registers": {"s0": "0xFFFFFFFF", "s1": 0}
      },
      "expected_behavior": {
        "registers": {
          "s2": 1,
          "s3": 0
        }
      },
      "comment": "SLT and SLTU perform signed and unsigned compares respectively, writing 1 to rd if rs1 < rs2, 0 otherwise.",
      "spec_section": "2.4.2",
      "python_verification": "s0 = 0xFFFFFFFF; s1 = 0; s2 = 1 if s1 < s0 else 0; s3 = 1 if s0 < s1 else 0  # s2=1 (0 < max), s3=0 (max > 0)",
      "edge_case": true
    },
    {
      "name": "SLT with negative numbers",
      "hint_marker": 11,
      "instructions": ["SLT"],
      "initial_state": {
        "registers": {"a0": -1, "a1": -2}
      },
      "expected_behavior": {
        "registers": {
          "a2": 0,
          "a3": 1
        }
      },
      "comment": "SLT and SLTU perform signed and unsigned compares respectively, writing 1 to rd if rs1 < rs2, 0 otherwise.",
      "spec_section": "2.4.2",
      "python_verification": "a0 = -1; a1 = -2; a2 = 1 if a0 < a1 else 0; a3 = 1 if a1 < a0 else 0  # a2=0 (-1 > -2), a3=1 (-2 < -1)"
    },
    {
      "name": "XOR self-cancellation",
      "hint_marker": 12,
      "instructions": ["XOR"],
      "initial_state": {
        "registers": {"t0": "0x12345678"}
      },
      "expected_behavior": {
        "registers": {
          "t1": 0,
          "t2": "0x12345678"
        }
      },
      "comment": "AND, OR, and XOR perform bitwise logical operations.",
      "spec_section": "2.4.2",
      "python_verification": "t0 = 0x12345678; t1 = t0 ^ t0; t2 = t0 ^ 0  # t1=0 (x XOR x = 0), t2=t0 (x XOR 0 = x)",
      "notes": ["x XOR x = 0", "x XOR 0 = x"]
    },
    {
      "name": "Maximum and minimum I-type immediates",
      "hint_marker": 13,
      "instructions": ["ADDI"],
      "expected_behavior": {
        "registers": {
          "s4": 2047,
          "s5": -2048
        }
      },
      "comment": "ADDI adds the sign-extended 12-bit immediate to register rs1.",
      "spec_section": "2.4.1",
      "python_verification": "s4 = 0 + 2047; s5 = 0 + (-2048)  # 12-bit signed range: -2048 to 2047",
      "edge_case": true,
      "notes": ["I-type immediate range: -2048 to +2047 (12-bit signed)"]
    },
    {
      "name": "LUI with maximum value",
      "hint_marker": 14,
      "instructions": ["LUI"],
      "expected_behavior": {
        "registers": {
          "s6": "0xFFFFF000"
        }
      },
      "comment": "LUI (load upper immediate) places the 20-bit U-immediate into bits 31â€“12 of register rd and places zero in the lowest 12 bits.",
      "spec_section": "2.4.1",
      "python_verification": "s6 = 0xFFFFF << 12  # s6 = 0xFFFFF000",
      "edge_case": true
    },
    {
      "name": "AUIPC with maximum offset",
      "hint_marker": 15,
      "instructions": ["AUIPC"],
      "expected_behavior": {
        "registers": {
          "s7": "PC + 0xFFFFF000"
        }
      },
      "comment": "AUIPC (add upper immediate to pc) forms a 32-bit offset from the 20-bit U-immediate, filling in the lowest 12 bits with zeros, adds this offset to the address of the AUIPC instruction, then places the result in register rd.",
      "spec_section": "2.4.1",
      "edge_case": true
    },
    {
      "name": "BEQ with equal values - taken",
      "hint_marker": 16,
      "instructions": ["BEQ"],
      "initial_state": {
        "registers": {"t0": 42, "t1": 42}
      },
      "expected_behavior": {
        "registers": {
          "t2": 1
        },
        "pc_change": "branch taken"
      },
      "comment": "BEQ and BNE take the branch if registers rs1 and rs2 are equal or unequal respectively.",
      "spec_section": "2.5.2"
    },
    {
      "name": "BNE with equal values - not taken",
      "hint_marker": 17,
      "instructions": ["BNE"],
      "initial_state": {
        "registers": {"t0": 42, "t1": 42}
      },
      "expected_behavior": {
        "registers": {
          "t3": 1
        },
        "pc_change": "branch not taken"
      },
      "comment": "BEQ and BNE take the branch if registers rs1 and rs2 are equal or unequal respectively.",
      "spec_section": "2.5.2"
    },
    {
      "name": "BGE with equal values - taken",
      "hint_marker": 18,
      "instructions": ["BGE"],
      "initial_state": {
        "registers": {"t0": 42, "t1": 42}
      },
      "expected_behavior": {
        "registers": {
          "t4": 1
        },
        "pc_change": "branch taken"
      },
      "comment": "BGE and BGEU take the branch if rs1 is greater than or equal to rs2, using signed and unsigned comparison respectively.",
      "spec_section": "2.5.2",
      "notes": ["Equal values satisfy >= condition"]
    },
    {
      "name": "BGEU with equal values - taken",
      "hint_marker": 19,
      "instructions": ["BGEU"],
      "initial_state": {
        "registers": {"t0": 42, "t1": 42}
      },
      "expected_behavior": {
        "registers": {
          "t5": 1
        },
        "pc_change": "branch taken"
      },
      "comment": "BGE and BGEU take the branch if rs1 is greater than or equal to rs2, using signed and unsigned comparison respectively.",
      "spec_section": "2.5.2",
      "notes": ["Equal values satisfy >= condition for both signed and unsigned"]
    }
  ]
}
